ê·¸ë˜í”„ ì´ë¡ 
=
í•´ë‹¹ ì±•í„°ì—ì„œëŠ” ì•ì—ì„œ ë°°ìš´ ë‚´ìš©ì„ í† ëŒ€ë¡œ ë‹¤ì–‘í•œ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ì„ ë°°ìš¸ ê²ƒì´ë‹¤.   
ë‚´ìš©ìœ¼ë¡œëŠ” í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜, ìœ„ìƒ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë“±ì´ ìˆë‹¤.   
ê·¸ ì™¸ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ ë•Œ ê°œì²´ê°„ ì—°ê²°ëœ ë‚´ìš©ì˜ ë¬¸ì œëŠ” ê·¸ë˜í”„ ë¬¸ì œë¼ ìƒê°í•˜ê³ , ë…¸ë“œì™€ ê°„ì„ ì„ ì„ ì •í•˜ì—¬ ê·¸ë˜í”„ë¥¼ ë§Œë“¤ì–´ í’€ì–´ì•¼ í•œë‹¤.
### ê·¸ë˜í”„(Graph)
> ê·¸ë˜í”„(Graph) : ë…¸ë“œ(Node)ì™€ ë…¸ë“œ ì‚¬ì´ì— ì—°ê²°ëœ ê°„ì„ (edge)ì˜ ì •ë³´ë¥¼ ê°€ì§€ê³  ìˆëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì˜ë¯¸í•œë‹¤.

ìë£Œêµ¬ì¡° ì¤‘ íŠ¸ë¦¬(Tree)ìë£Œêµ¬ì¡°ëŠ” ë‹¤ì–‘í•œ ì•Œê³ ë¦¬ì¦˜ì— ì‚¬ìš©ë˜ë¯€ë¡œ ê¼­ ê¸°ì–µí•´ì•¼ í•œë‹¤.
>ìµœì†Œ í™: í•­ìƒ ë¶€ëª¨ ë…¸ë“œê°€ ìì‹ ë…¸ë“œì˜ í¬ê¸°ë³´ë‹¤ ì‘ì€ ìë£Œêµ¬ì¡°  
>ìµœëŒ€ í™: í•­ìƒ ë¶€ëª¨ ë…¸ë“œê°€ ìì‹ ë…¸ë“œì˜ í¬ê¸°ë³´ë‹¤ í° ìë£Œêµ¬ì¡°

íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ëŠ” ë¶€ëª¨ì—ì„œ ìì‹ìœ¼ë¡œ ë‚´ë ¤ì˜¤ëŠ” ê³„ì¸µì ì¸ ëª¨ë¸ì— ì†í•œë‹¤.
    
|                 |      **ê·¸ë˜í”„**      |  **íŠ¸ë¦¬**   |
|:---------------:|:-----------------:|:---------:|
|     **ë°©í–¥ì„±**     | ë°©í–¥ ê·¸ë˜í”„ í˜¹ì€ ë¬´ë°©í–¥ ê·¸ë˜í”„ |  ë°©í–¥ ê·¸ë˜í”„   |
|     **ìˆœí™˜ì„±**     |     ìˆœí™˜ ë¹› ë¹„ìˆœí™˜      |    ë¹„ìˆœí™˜    |
| **ë£¨íŠ¸ ë…¸ë“œ ì¡´ì¬ ì—¬ë¶€** |     ë£¨íŠ¸ ë…¸ë“œê°€ ì—†ìŒ     | ë£¨íŠ¸ ë…¸ë“œê°€ ì¡´ì¬ |
|   **ë…¸ë“œê°„ ê´€ê³„ì„±**   |   ë¶€ëª¨ì™€ ìì‹ ê´€ê³„ ì—†ìŒ    | ë¶€ëª¨ì™€ ìì‹ ê´€ê³„ |
|   **ëª¨ë¸ì˜ ì¢…ë¥˜**    |      ë„¤íŠ¸ì›Œí¬ ëª¨ë¸      |   ê³„ì¸µ ëª¨ë¸   |

ê·¸ë˜í”„ì˜ êµ¬ê°€ì§€ êµ¬í˜„ ë°©ì‹ ë° ì‹œê°„ ë³µì¡ë„(ë…¸ë“œì˜ ê°œìˆ˜ê°€ V ê°„ì„ ì˜ ê°œìˆ˜ê°€ Eì¼ ë•Œ)
> ì¸ì ‘ í–‰ë ¬(Adjacency Matrix)
> - 2ì°¨ì› ë°°ì—´ì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹
> - ì‹œê°„ ë³µì¡ë„: O(V^2)
> - íŠ¹ì • ë…¸ë“œì—ì„œ ë…¸ë“œë¡œ ì´ë™í•  ë•Œ ë“œëŠ” ê°„ì„ ì˜ ë¹„ìš©ì„ ì•„ëŠ”ë° O(1)
> 
> ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjacency List)
> - ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ì‹
> - ì‹œê°„ ë³µì¡ë„: O(E)
> - íŠ¹ì • ë…¸ë“œì—ì„œ ë…¸ë“œë¡œ ì´ë™í•  ë•Œ ë“œëŠ” ê°„ì„ ì˜ ë¹„ìš©ì„ ì•„ëŠ”ë° O(V)

### ì„œë¡œì†Œ ì§‘í•© (Disjoint Sets)
> ì„œë¡œì†Œ ì§‘í•©(Disjoint Sets) : ì´ë€ ê³µí†µ ì›ì†Œê°€ ì—†ëŠ” ë‘ ì§‘í•©ì„ ì˜ë¯¸í•˜ê³ , ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°ëŠ” ì„œë¡œì†Œ ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ„ì–´ì§„ ì›ì†Œë“¤ì˜ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°ë¼ê³  í•  ìˆ˜ ìˆë‹¤.   

ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°ëŠ” unionê³¼ find ì´ 2ê°œì˜ ì—°ì‚°ìœ¼ë¡œ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.   
ìŠ¤íƒ(stack)ê³¼ í(queue)ê°€ ê°ê° push(ë„£ê¸°)ì™€ pop(êº¼ë‚´ê¸°) ì—°ì‚°ìœ¼ë¡œ ì´ë£¨ì–´ì¡Œë˜ ê²ƒì²˜ëŸ¼, ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ í•©ì§‘í•©ê³¼ ì°¾ê¸° ì—°ì‚°ìœ¼ë¡œ êµ¬ì„±ëœë‹¤.   
ê·¸ë˜ì„œ ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°ëŠ” union-find(í•©ì¹˜ê¸° ì°¾ê¸°) ìë£Œêµ¬ë¡œë¼ê³  ë¶ˆë¦¬ê¸°ë„ í•œë‹¤. 
- union(í•©ì§‘í•©): 2ê°œì˜ ì›ì†Œê°€ í¬í•¨ëœ ì§‘í•©ì„ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹˜ëŠ” ì—°ì‚°.
- find(ì°¾ê¸°): íŠ¹ì •í•œ ì›ì†Œê°€ ì†í•œ ì§‘ì´ ì–´ë–¤ ì§‘í•©ì¸ì§€ ì•Œë ¤ì£¼ëŠ” ì—°ì‚°.  

ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°ë¥¼ êµ¬í˜„í•  ë•ŒëŠ” íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ ì§‘í•©ì„ í‘œí˜„í•˜ëŠ”ë°, ì„œë¡œì†Œ ì§‘í•© ì •ë³´(í•©ì§‘í•© ì—°ì‚°)ê°€ ì£¼ì–´ì¡Œì„ ë•Œ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•´ì„œ ì§‘í•©ì„ í‘œí˜„í•˜ëŠ” ì„œë¡œì†Œ ì§‘í•© ê³„ì‚° ì•Œê³ ë¦¬ì¦˜ê³¼ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. 
> 1. union(í•©ì§‘í•©) ì—°ì‚°ì„ í•˜ì—¬, ì„œë¡œ ì—°ê²°ëœ ë‘ ë…¸ë“œ A, Bë¥¼ í™•ì¸í•œë‹¤.   
> 	I Aì™€ Bì˜ ë£¨íŠ¸ë…¸ë“œ A', B'ë¥¼ ê°ê° ì°¾ëŠ”ë‹¤.   
> II A'ë¥¼ B'ì˜ ë¶€ëª¨ ë…¸ë¡œ ì„¤ì •í•œë‹¤.(B'ê°€ A'ë¥¼ ê°€ë¥´í‚¤ë„ë¡ í•œë‹¤.)
> 2. ëª¨ë“  union(í•©ì§‘í•©) ì—°ì‚°ì„ ì²˜ë¦¬í•  ë•Œ ê¹Œì§€ 1ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.


~~~python
# íŠ¹ì • ì›ì†Œê°€ ì†í•œ ì§‘í•©ì„ ì°¾ê¸°
def find_parent(parent, x):
    # ë£¨íŠ¸ ë…¸ë“œê°€ ì•„ë‹ˆë¼ë©´ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œ
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x


# ë‘ ì›ì†Œê°€ ì†í•œ ì§‘í•©ì„ í•©ì¹˜ê¸°
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b


# ë…¸ë“œì˜ ê°œìˆ˜ì™€ ê°„ì„ (union ì—°ì‚°)ì˜ ê°œìˆ˜ ì…ë ¥ë°›ê¸°
v, e = map(int, input().split())
parent = [0] * (v + 1)  # ë¶€ëª¨ í…Œì´ë¸” ì´ˆê¸°í™”

# ë¶€ëª¨ í…Œì´ë¸” ìƒì—ì„œ, ë¶€ëª¨ë¥¼ ìê¸° ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
for i in range(1, v + 1):
    parent[i] = i

# union ì—°ì‚°ì„ ê°ê° ìˆ˜í–‰
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# ê° ì›ì†Œê°€ ì†í•œ ì§‘í•© ì¶œë ¥
print('ê° ì›ì†Œê°€ ì†í•œ ì§‘í•©: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

# ë¶€ëª¨ í…Œì´ë¸” ë‚´ìš© ì¶œë ¥
print('ë¶€ëª¨ í…Œì´ë¸”: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
~~~
í•´ë‹¹ ì½”ë“œì—ì„œ ê°€ì¥ ë°‘ì— ìˆëŠ” ìì‹ë…¸ë“œì—ì„œ ìµœìƒìœ„ ë¶€ëª¨ë…¸ë“œë¥¼ ì°¾ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ ë³µì¡ë„ëŠ” O(VM)ì´ ëœë‹¤(ë…¸ë“œì˜ ìˆ˜ V * find or union ê°œìˆ˜ M). ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ê²½ë¡œ ì••ì¶• ê¸°ë²•ì„ ì‚¬ìš©í•œë‹¤.
~~~python
# find í•¨ìˆ˜ì—ì„œ ifë¬¸ ë‚´ë¶€ì—ì„œ ë£¨íŠ¸ë…¸ë“œë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ì¬ê·€ í˜¸ì¶œ í•œë‹¤.
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]
~~~
### ì„œë¡œì†Œ ì§‘í•©ì„ í™œìš©í•œ ì‚¬ì´í´ íŒë³„
union ì—°ì‚°ì€ ê·¸ë˜í”„ì—ì„œ ê°„ì„ ìœ¼ë¡œ í‘œí˜„ë  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ ê°„ì„ ì„ í•˜ë‚˜ì”© í™•ì¸í•˜ë©´ì„œ ë‘ ë…¸ë“œê°€ í¬í•¨ë˜ì–´ ìˆëŠ” ì§‘í•©ì„ í•©ì¹˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•˜ëŠ” ê²ƒë§Œìœ¼ë¡œë„ ì‚¬ì´í´ì„ íŒë³„í•  ìˆ˜ ìˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
1. ê° ê°„ì„ ì„ í™•ì¸í•˜ë©° ë‘ ë…¸ë“œì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ í™•ì¸í•œë‹¤.   
I ë£¨íŠ¸ ë…¸ë“œê°€ ì„œë¡œ ë‹¤ë¥´ë‹¤ë©´ ë‘ ë…¸ë“œì— ëŒ€í•˜ì—¬ union ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.   
II  ë£¨íŠ¸ ë…¸ë“œê°€ ì„œë¡œ ê°™ë‹¤ë©´ ì‚¬ì´í´(Cycle)ì´ ë°œìƒí•œ ê²ƒì´ë‹¤. 
2. ê·¸ë˜í”„ì— í¬í•¨ë˜ì–´ ìˆëŠ” ëª¨ë“  ê°„ì„ ì— ëŒ€í•˜ì—¬ 1ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

ì´ëŸ¬í•œ ì‚¬ì´í´ íŒë³„ ì•Œê³ ë¦¬ì¦˜ì€ ë°©í–¥ì„±ì´ ì—†ëŠ” ë¬´ë±¡í–¥ ê·¸ë˜í”„ì—ë§Œ ì ìš© ê°€ëŠ¥í•˜ë©° ê°„ì„ ì˜ ê°œìˆ˜ê°€ Eì¼ ë•Œ, ë§¤ ê°„ì„ ë§ˆë‹¤ union ë° find í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ì‹œê¸ë¡œ ë™ì‘í•œë‹¤.
~~~python
# judge_cycle
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]


def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a <= b:
        parent[b] = a
    else:
        parent[a] = b

        
v, e = map(int, input().split())
parent = [0] * (v + 1)

for i in range(1, v + 1):
    parent[i] = i

cycle = False

for i in range(e):
    a, b = map(int, input().split())
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        break
    else:
        union_parent(parent, a, b)

if cycle:
    print('ì‚¬ì´í´ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
else:
    print('ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.')
~~~

### ì‹ ì¥ íŠ¸ë¦¬(Spanning Tree)
> ì‹ ì¥ íŠ¸ë¦¬(Spanning Tree): í•˜ë‚˜ì˜ ê·¸ë˜í”„ê°€ ìˆì„ ë•Œ ëª¨ë“  ë…¸ë“œë¥¼ í¬í•¨í•˜ë©´ì„œ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë¶€ë¶„ ê·¸ë˜í”„

### í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal Algorithm)
ì‹ ì¥ íŠ¸ë¦¬ ì¤‘ì—ì„œ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ì‹ ì¥íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ 'ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜' ì´ë¼ê³  í•˜ëŠ”ë°, ì´ ì¤‘ ëŒ€í‘œì ì€ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ Kruskal Alhorithmì´ ì¡´ì¬í•œë‹¤.
> í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal Algorithm): ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë¶„ë¥˜ë˜ê³ , ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ ì •ë ¬ì„ ìˆ˜í–‰í•œ ë’¤ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ê°„ì„ ë¶€í„° ì§‘í•©ì— í¬í•¨ì‹œí‚¨ë‹¤. ì´ë•Œ ì‚¬ì´í´ì„ ë°œìƒí•  ìˆ˜ ìˆëŠ” ê°„ì„ ì€ ì§‘í•©ì— í¬í•©ì‹œí‚¤ì§€ ì•ŠëŠ”ë‹¤.
> ### êµ¬ì²´ì  ì•Œê³ ë¦¬ì¦˜
> 1. ê°„ì„  ë°ì´í„°ë¥¼ ë¹„ìš©ì— ë”°ë¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œë‹¤.
> 2. ê°„ì„ ì„ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° í˜„ì¬ì˜ ê°„ì„ ì´ ì‚¬ì´í´ì„ ë°œìƒì‹œí‚¤ëŠ”ì§€ í™•ì¸í•œë‹¤.
> I. ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•ŠëŠ” ê²½ìš° ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ì‹œí‚¨ë‹¤. 
> II. ì‚¬ì´í´ì´ ë°œìƒí•˜ëŠ” ê²½ìš° ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ì‹œí‚¤ì§€ ì•ŠëŠ”ë‹¤.
> 3. ëª¨ë“  ê°„ì„ ì— ëŒ€í•˜ì—¬ 2ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.   

- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ë¹„ìš©ì„ êµ¬í•˜ëŠ” í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì½”ë“œ. ğŸ‘‡ğŸ»
~~~python
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]


def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a <= b:
        parent[b] = a
    else:
        parent[a] = b


v, e = map(int, input().split())
parent = [0] * (v + 1)

edges = []
result = 0

for i in range(1, v + 1):
    parent[i] = i

for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b))

edges.sort()

for edge in edges:
    cost, a, b = edge
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost

print(result)
~~~
í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„ëŠ” Eê°œì˜ ê°„ì„ ì„ ì •ë ¬í•  ë•Œ ê°€ì¥ ì˜¤ëœ ì‹œê°„ì„ ì°¨ì§€í•˜ê³  ë‹¤ìŒê³¼ ê°™ë‹¤.   
#### <center>O(ElogE)</center>


### ìœ„ìƒ ì •ë ¬(Topology Sort)
> ìœ„ìƒ ì •ë ¬(Topology Sort): ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì¼ì¢…. ìˆœì„œê°€ ì •í•´ì ¸ ìˆëŠ” ì¼ë ¨ì˜ ì‘ì—…ì„ ì°¨ë¡€ëŒ€ë¡œ ìˆ˜í–‰í•´ì•¼ í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.   
> ë°©í–¥ ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œë¥¼ 'ë°©í–¥ì„±ì— ê±°ìŠ¤ë¥´ì§€ ì•Šë„ë¡ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•˜ëŠ” ê²ƒ'
> - ì§„ì… ì°¨ìˆ˜(Indegree): íŠ¹ì • í•œ ë…¸ë“œë¡œ 'ë“¤ì–´ì˜¤ëŠ”' ê°„ì„ ì˜ ê°œìˆ˜
> ### ìœ„ìƒ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
> 1. ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¥¼ íì— ë„£ëŠ”ë‹¤.
> 2. íê°€ ë¹Œ ë•Œê¹Œì§€ ë‹¤ìŒ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.   
> I. íì—ì„œ ì›ì†Œë¥¼ êº¼ë‚´ í•´ë‹¹ ë…¸ë“œì—ì„œ ì¶œë°œí•˜ëŠ” ê°„ì„ ì„ ê·¸ë˜í”„ì—ì„œ ì œê±°í•œë‹¤.   
> II. ìƒˆë¡­ê²Œ ì§„ì… ì°¨ìˆ˜ê°€ 0ì´ ëœ ë…¸ë“œë¥¼ íì— ë„£ëŠ”ë‹¤.   
> 
> ì—¬ê¸°ì„œ ëª¨ë“  ì›ì†Œë¥¼ ë°©ë¬¸í•˜ê¸°(íì—ì„œ ì›ì†Œê°€ Vë²ˆ ì¶”ì¶œë˜ê¸°) ì „ íê°€ ë¹ˆë‹¤ë©´ ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ê³  íŒë‹¨í•  ìˆ˜ ìˆë‹¤.

ìœ„ìƒ ì •ë ¬ì€ íì—ì„œ ì¶”ì¶œëœ ì›ì†Œì˜ ìˆœì„œë¥¼ ì˜ë¯¸í•˜ê³ , íì— ì‚½ì…í•˜ëŠ” ìˆœì„œì— ë”°ë¼ ë³µìˆ˜ì˜ ë‹µì´ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.
~~~python
from collections import deque

v, e = map(int, input().split())
indegree = [0] * (v + 1)
graph = [[] for _ in range(v + 1)]

for _ in range(e):
    a, b = map(int, input().split())
    graph[a].append(b)
    indegree[b] += 1


def topology_sort():
    result = []
    q = deque()

    for i in range(1, v + 1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        now = q.popleft()
        result.append(now)
        for i in graph[now]:
            indegree[i] -= 1
            if indegree[i] == 0:
                q.append(i)

    for i in result:
        print(i, end=' ')


topology_sort()
~~~

ìœ„ìƒ ì •ë ¬ì˜ ì‹œê°„ë³µì¡ë„ëŠ” ëª¨ë“  ë…¸ë“œë¥¼ í™•ì¸í•˜ë©´ì„œ, í•´ë‹¹ ë…¸ë“œì˜ ì¶œë°œí•˜ëŠ” ê°„ì„ ì„ ì°¨ë¡€ëŒ€ë¡œ ì œê±°í•´ì•¼ í•˜ê³ , ë‹¤ìŒê³¼ ê°™ë‹¤.
#### <center>O(V + E)</center>

