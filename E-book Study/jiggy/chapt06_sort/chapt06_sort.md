정렬
=
## 정렬 알고리즘 개요
**정렬(sorting)** : 데이터를 특정한 기준에 따라서 순서대로 나열하는 것    
- ex) 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬

정렬 알고리즘은 탐색을 더 편리하게 도와주는 역할을 한다.

### 선택 정렬
**선택 정렬** : 가장 원시적인 정렬 방법
> 1. 데이터가 무작위로 있을 때 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾼다.
> 2. 그다음 작은 데이터를 선택해 두 번째 데이터와 바꾸는 과정을 반복한다.

즉, 매번 작은 것을 선택한다는 의미에서 선택 정렬 알고리즘 이라고 한다. 

**선택 정렬 코드**
~~~python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i]

print(array)
~~~

선택 정렬의 시간 복잡도는 두 개의 for 문을 통해 정렬이 이루어지므로, 아래와 같다.
> O(N**2)

### 삽입 정렬

**삽입 정렬** : 삽입 정렬은 이미 정렬돼 있는 배열에 다음 인덱스를 가장 적절한 위치에 삽입하는 알고리즘 이다.

> 1. 첫 인덱스는 하나의 숫자이기 때문에 이미 정렬돼 있는 상태이다.    
>다음 인덱스를 첫 인덱스의 좌측에 삽입할지 우측에 삽입할지 정하여 정렬한다.
> 2. 다음 세 번째 인덱스를 앞의 정렬돼 있는 배열에 어디에 삽입할지 정해 정렬한다.
> 3. 위 두 과정을 반복해 마지막 인덱스 까지 정렬 삽입하여 정렬 시킨다.
> ~~~python
> array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
>
> for i in range(1, len(array)):
>     for j in range(i, 0, -1):
>         if array[j] < array[j-1]:
>             array[j], array[j-1] = array[j-1], array[j]
>         else:
>             break
>            
> print(array)
>
> ~~~
> 삽입 정렬의 시간 복잡도 : O(N**2) 이지만 최선의 경우 O(N)의 시간 복잡도를 갖는다.

### 퀵 정렬
**퀵 정렬** : 가장 많이 사용되는 알고리즘으로 퀵 정렬에는 피벗이라는 개념이 등장한다.
* Pivot - 큰 숫자와 작은 숫자를 나누는 기준이 되는 숫자

퀵 정렬은 피벗(Pivot)을 정하고 피벗을 기준으로 큰 숫자와 작은 숫자를 나눈다.   
피벗을 설정하고 리스트를 분할하는 방법에 따라서 여려 가지 방식으로 퀵 정렬을 구분하는데, 이코테 책에서는 가장 대표적인 분할 방식인 호어 분할 방식을 기준으로 퀵 정렬을 설명한다.
> 1. 리스트에서 첫 번째 데이터를 피벗으로 정한다.
> 2. 리스트의 왼쪽에서부터 피벗보다 큰 데이터를 찾고 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.
> 3. 그다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.
> 4. 위 과정을 반복해 주면 피벗을 기준으로 정렬이 이루어 진다.

퀵 정렬의 시간복잡도는 다음과 같다. 
* O(NlogN) 최악의 경우 O(N**2)

~~~python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array

    pivot = array[0]    # 피벗은 첫 번쨰 원소
    tail = array[1:]    # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot]     # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot]     # 분할된 오른쪽 부분

    # 분할 이후 왼쪽과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)


print(quick_sort(array))
~~~

### 계수 정렬
**계수 정렬(Count Sort)** : 모든 범위를 담을 수 있는 리스트를 선언하여 정렬할 리스트의 계수를 인덱스에 맞게 넣어 매우 간단하게 정렬을 하는 방법이다.
그러나 리스트를 통한 정렬이기에 몇가지 제약 사항이 존재 한다.
* 최대값이 1,000,000 이상의 수면 안된다.
* 정렬할 모든 수가 양의 정수이어야 한다.
* 최대값과 최소값의 차이가 너무 크면 효율성이 크게 떨어진다.

> **계수 정렬의 과정**
> 1. 정렬할 리스트의 최대값 + 1 크기의 리스트를 생성    
(리스트 내 모든 값은 0으로 초기화)
> 2. 정렬할 리스트 내부 값을 생성한 리스트 인덱스에 +1
> 3. 과정 반복 후 값이 존재하는 리스트의 개수 만큼 차례로 출력

- 시간 복잡도 - O(N + K)    
계수 정렬은 현존하는 정렬 알고리즘 중 기수 정렬과 더불어 가장 빠르다.
- 공간 복잡도 - O(N + K)

~~~python
# 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1    # 각 데이터에 해당하는 인덱스의 값 증가
    
for i in range(len(count)):    # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ')   # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

~~~
