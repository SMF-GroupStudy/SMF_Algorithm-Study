## 다이나믹 프로그래밍(Dynamic Programming)
* 탑 다운 & 보텀 업
* 대표적인 예시로 피보나치 수열이 있음.
#### 피보나치 수열
An = An-1 + An-2, A1 = 1, A2 = 1<br>
n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수<br>
단, 1번째 피보나치 수 = 1 , 2번째 피보나치 수 = 1
```bazaar
#피보나치 함수(Fibonacci Function)를 재귀 함수로 표현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)
print(fibo(4))
```
빅오 표기법 O(2^n)2의 n승 <code>**N=30이면 약 10억가량의 연산**</code>을 수행해야함.

#### 다이나믹 프로그래밍의 조건
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
* 피보나치 수열은 이러한 조건을 만족하는 대표 문제
* 메모제이션 기법을 활용하여 해결 
* <code>**메모제이션?**</code> - 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미 캐싱(caching)이라고도 함.

````bazaar
#피보나치 수열 재귀적 메모제이션
d = [0] * 100
# 피보나치 함수를 재귀함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]
print(fibo(99))
````
* 다이나믹 프로그래밍이란? 큰문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법
* 다이나믹 프로그래밍을 적용시키면 O(N)이 됨.
* 위 방식들이 탑 다운 방식

##### 보텀 업 방식
```bazaar
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99
for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]
print(d[n])
```
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.